
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       This is the end of the debugging code and beginning of the code
c       proper.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       This file contains code for constructing quadratures for
c       a collection of functions f_1,...,f_N given over a planar
c       region.  It operates by solving the system of equations
c
c          \sum_l f_j(x_l,y_l) w_l = \int f_j(x) dx    j=1,...,N        (1)
c              
c       for the weights and/or nodes of a quadrature.
c
c       In the case of the routine chebquad, a basic solution of the
c       *linear* system obtained by letting the nodes (x_l,y_l) in (1) 
c       be the nodes of an oversamped quadrature formula integrating the 
c       functions f_j is constructed in order to compute an N-point
c       quadrature for the f_j.
c
c       In the case of gaussquad, the nonlinear system (1) is solved
c       by reducing an existing quadrature formula for the f_j point-
c       by-point.  In particular, given an existing M-point formula,
c       a quadrature node is (carefully) selected for removal and the
c       resulting (M-1)-point formula is used as an initial value
c       for Gauss-Newton type iterations.  The process is repeated
c       until an accurate formula can no longer be obtained.
c
c       The input to the user-callable procedures is in each case an
c       external subroutine which returns the values and possibly the
c       first derivatives of the input functions at a given point.
c
c       Notes:
c
c    1. The quadratures generated by these routines are not 
c       guaranteed to have positive weights or interior nodes, but
c       some care is taken to "encourage" them to do so.
c
c    2. The evaluation of input functions is by far the most time-
c       consuming operation peformed by the code.  The user is 
c       urged to take care in generating efficient representations
c       for the input functions.
c
c    3. If the input functions are not orthogonal or nearly so, then
c       the systems of equations solved by these routines can become
c       poorly conditioned.  Similarly, if the "scales" of the
c       input functions vary widely, then the routine will generally
c       fail or perform suboptimally.  It is highly suggested that 
c       orthonormal input functions be used.
c
c       The following subroutines are user-callable:
c
c   chebquad - construct a quadrature by solving the linear system
c       (1)
c
c   gaussquad - further downsample an existing quadrature for a 
c       collection of orthonormal input functions by applying 
c       Gauss-Newton iteratons to the obvious nonlinear system of 
c       equations to reduce the quadrature point-by-point.
c
c   refquad - use Newton iterations to refine an existing quadrature
c       formula
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc



        subroutine chebquad(nfuns,funeval,par1,par2,par3,par4,
     1    nquad0,xs0,ys0,whts0,nquad,xs,ys,whts,rints)
        implicit double precision (a-h,o-z)
        dimension xs0(1),ys0(1),whts0(1),xs(1),ys(1),whts(1),rints(1)
c
        double precision, allocatable :: vals0(:),dersx0(:),dersy0(:)

!        dimension vals0(10 000),dersx0(10 000),dersy0(10 000)
c        dimension rnorms(100 000),ipivs(200 000),sol(10000)
c
        double precision, allocatable :: vals(:,:),a(:,:),b(:,:)
        double precision, allocatable :: rnorms(:),sol(:)
c
        integer, allocatable :: ipivs(:)
        external funeval
c
        allocate(vals0(10 000),dersx0(10 000),dersy0(10 000))

c
c       Construct a k-point quadrature for a collection of k orthonormal
c       functions given an existing n-point quadrature integrating their
c       products.
c
c       This procedure operates by producing a basic solution to the
c       obvious linear system of equations.  Note the resulting 
c       quadrature will have interior nodes but is not guaranteed to 
c       have positive weights.
c
c                          Input Parameters:
c
c   nfuns - the number of input functions in the orthonormal collection
c
c   funeval - a user-supplied external subroutine for evaluating the
c       input functions and their derivatives at a collection of points;
c       the calling syntax for funeval is as follows:
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       subroutine funeval(x,y,par1,par2,par3,par4,vals,dersx,
c    1    dersy,ifinvalid)
c
c       Return the values of the input functions and their derivatives
c       w.r.t. x and y at the point (x,y) in the arrays vals, dersx,
c       and dersy.  The parameters par? are arbitarily typed 
c       user-supplied parameters.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c   nquad0 - the number of points in the initial quadrature formula
c   (xs0,ys0) - the coordinates of the nodes in the initial formula
c   whts0 - the initial quadrature weights
c
c                        Output Parameters:
c
c   nquad - the number of points in the downsampled formula
c   (xs,y) - the coordinates of the nodes of the downsampled formula
c   whts - the quadrature weights for the downsampled formula
c
c   rints - upon return, this user-supplied array will contain the
c       integrals of the input functions as computed using the 
c       initial quadrature.
c
c       Allocate memory for the procedure.
c
        allocate ( vals(nquad0,nfuns), a(nfuns,nquad0) )
        allocate ( b(nfuns,nfuns) )
c
        allocate(rnorms(nfuns+nquad0+1),sol(nfuns+nquad0+1))
        allocate(ipivs(nfuns+nquad0+1))
c
c       Evaluate the functions at the quadrature nodes.
c
        do 1000 i=1,nquad0
c
        x=xs0(i)
        y=ys0(i)
c
        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,
     -   ifinvalid)
c
c       We shouldn't get an invalid point in chebquad.
c
        if (ifinvalid .eq. 1) then
        call prinf("after funeval, ifinvalid = *",ifinvalid,1)
        call prin2("x=*",x,1)
        call prin2("y=*",y,1)
        stop
        endif
c
        do 1100 j=1,nfuns
        vals(i,j)=vals0(j)
 1100 continue
 1000 continue

c
c       Compute the integrals of the functions.
c
        do 1200 j=1,nfuns
        sum=0
        do 1300 i=1,nquad0
        wht=whts0(i)
        sum=sum+vals(i,j)*wht
 1300 continue
        rints(j)=sum
        sol(j)=sum
 1200 continue
c
        call prin2("in chebquad, rints = *",rints,nfuns)

c
c       Use GS to pick quadrature nodes.
c
        do 2000 i=1,nquad0
        wht=whts0(i)
        do 2100 j=1,nfuns
        a(j,i)=vals(i,j)*sqrt(wht)
 2100 continue
 2000 continue
c
        call gspiv2(a,nfuns,nquad0,rnorms,ipivs)
        call prin2("in chebquad, rnorms=*",rnorms,nfuns)
        call prinf("in chebquad, ipivs=*",ipivs,nfuns)
c
c       Solve a linear system in order to construct weights.
c
        do 3000 j=1,nfuns
        do 3100 i=1,nfuns
        ii=ipivs(i)
        b(j,i)=vals(ii,j)*sqrt(whts0(ii))
 3100 continue
 3000 continue
c
        call qrsolv(b,nfuns,sol,rcond)
c       
c       Compute the quadrature.
c
        nquad = nfuns
        do 4000 j=1,nquad
        jj=ipivs(j)
        xs(j) = xs0(jj)
        ys(j) = ys0(jj)
        whts(j) = sol(j)*sqrt(whts0(jj))
 4000 continue
c
        call prinf("in chebquad, nquad=*",nquad,1)
        call prin2("in chebquad, xs=*",xs,nquad)
        call prin2("in chebquad, ys=*",ys,nquad)
        call prin2("in chebquad, whts=*",whts,nquad)
c
        end

c
c
c

        subroutine gaussquad(ier,eps,nfuns,rints,funeval,par1,par2,par3,
     -    par4,nquad0,xs0,ys0,whts0,nquad,xs,ys,whts,
     -    funregion,par5,par6,ifaccept,ifpositive,ngoal)
        implicit double precision (a-h,o-z)
        dimension xs(1),ys(1),whts(1),rints(1)
        dimension xs0(1),ys0(1),whts0(1)
        double precision, allocatable :: vals0(:),dersx0(:)
        double precision, allocatable :: dersy0(:),signifs(:)
        double precision, allocatable :: sums(:)
        
!        dimension sums(nfuns+100)

c$$$        dimension vals0(10 000),dersx0(10 000),dersy0(10 000)
c$$$        dimension signifs(10 000),sums(nfuns+100)
c
c        double precision, allocatable :: vals0(:),dersx0(:)
c        double precision, allocatable :: dersy0(:),signifs(:)
c
        external funeval,funregion
c
c       Reduce an existing quadrature formula for a collection of 
c       functions point-by-point by solving the obvious nonlinear
c       system of equations via Gauss-Newton type iteration.       
c
c                           Input Parameters:
c
c   eps - the precision for the resulting quadrature
c   nfuns - the number of input functions in the orthonormal collection
c   rints - the integrals of the input functions; typically, this is 
c       computed by chebquad and passed to gaussquad
c
c   funeval - a user-supplied external subroutine for evaluating the
c       input functions and their derivatives at a collection of points;
c       the calling syntax for funeval is as follows:
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       subroutine funeval(x,y,par1,par2,par3,par4,vals,dersx,
c    1    dersy,ifinvalid)
c
c       Return the values of the input functions and their derivatives 
c       w.r.t. x and y at the point (x,y) in the arrays vals, dersx,
c       and dersy.  The parameters par? are arbitarily typed 
c       user-supplied parameters.
c       
c       The user should set the ifinvalid flag to 1 if the input
c       functions are not defined at the point (x,y).
c
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c   nquad - the number of points in the initial quadrature formula
c   (xs,ys) - the coordinates of the nodes in the initial formula
c   whts - the initial quadrature weights
c
c   funregion - a user-supplied input function which indicates whether
c       a point is inside of the integration domain or not; the calling
c       syntax is
c
c       subroutine funregion(x,y,isin,par5,par6)
c
c       Return 1 in the integer parameter isin if (x,y) is in the domain
c       of integration and 0 if is not. 
c
c   ifaccept - an integer parameter indicating whether quadrature nodes
c       outside of the domain should be accepted in intermediate 
c       calculations or not;
c
c       ifaccept = 0  indicates quadrature nodes outside of the domain
c                     of integration should not be accepted
c
c       ifaccept = 1  accept quadrature nodes outside of the domain of
c                     integration
c
c                        Output Parameters:
c
c   nquad - the number of points in the downsampled formula
c   (xs,y) - the coordinates of the nodes of the downsampled formula
c   whts - the quadrature weights for the downsampled formula
c
        ier = 0
c
        allocate(vals0(10 000),dersx0(10 000),dersy0(10 000))
        allocate(signifs(10 000),sums(nfuns+100))

        call mach_zero(eps0)
        eps0=eps0*20

        nquad = -1
c
c       Remove points, one-by-one (if possible).
c
 2000 continue
c
c       Compute significances for the points and reorder them.
c
        call compute_signifs(nfuns,funeval,par1,par2,par3,par4,
     -    nquad0,xs0,ys0,whts0,signifs,funregion,par5,par6,rints,
     -    ifpositive)
c
        call insort4(nquad0,signifs,xs0,ys0,whts0)
c
        call prinf("nquad0=*",nquad0,1)
        call prin2("xs0=*",xs0,nquad0)
        call prin2("ys0=*",ys0,nquad0)
        call prin2("whts0=*",whts0,nquad0)
        call prin2("signifs=*",signifs,nquad0)
c
c       Try to remove each point.
c        
        do 2100 ipt=1,nquad0
c
c        call prinf("ipt = *",ipt,1)
c
        call remove_point(iresult,ipt,eps,nfuns,funeval,par1,
     1    par2,par3,par4,nquad0,xs0,ys0,whts0,rints,funregion,par5,par6,
     -    ifaccept,eps0)
c        call prinf("iresult = *",iresult,1)
c
c       If the resulting formula is acceptable, copy into the output
c       variables.
c
        ifok = 1
c
        do 2200 i=1,nquad0
        x   = xs0(i)
        y   = ys0(i)
        wht = whts0(i)
c
        if (ifpositive .eq. 1 .AND. wht .lt. 0) then
        ifok = 0
        goto 2300
        endif
c
        call funregion(x,y,isin,par5,par6)
        if (isin .eq. 0) then
        ifok = 0
        goto 2300
        endif
 2200 continue
 2300 continue
c
        if(ifok .eq. 1) then         
        nquad=nquad0
        do 2400 i=1,nquad0
        xs(i)   = xs0(i)
        ys(i)   = ys0(i)
        whts(i) = whts0(i)
 2400 continue
        if (nquad .le. ngoal) goto 3000
        endif
c
        if (iresult .eq. 0) goto 2000
 2100 continue
c
 3000 continue
c
c       Otherwise, we are done.
c
        if (nquad .lt. 0) then
        ier = 1024
        return
        endif
c
        call prinf("nquad=*",nquad,1)
        call prin2("xs=*",xs,nquad)
        call prin2("ys=*",ys,nquad)
        call prin2("whts=*",whts,nquad)
c
        end



c$$$        subroutine refquad(iresult,eps,nfuns,funeval,par1,par2,par3,
c$$$     1    par4,nquad,xs,ys,whts,rints,funregion,par5,par6,ifaccept)
c$$$        implicit double precision (a-h,o-z)
c$$$        dimension xs(1),ys(1),whts(1),rints(1),z0(3*nquad)        
c$$$        dimension vals0(10000),dersx0(10000),dersy0(10000),sums(100000)
c$$$        external funeval,funregion
c$$$c        
c$$$c
c$$$c       Reduce an existing quadrature formula for a collection of 
c$$$c       functions point-by-point by solving the obvious nonlinear
c$$$c       system of equations via Gauss-Newton type iteration.       
c$$$c
c$$$c                           Input Parameters:
c$$$c
c$$$c   eps - the precision for the resulting quadrature
c$$$c   nfuns - the number of input functions in the orthonormal collection
c$$$c   rints - the integrals of the input functions; typically, this is 
c$$$c       computed by chebquad and passed to gaussquad
c$$$c
c$$$c   funeval - a user-supplied external subroutine for evaluating the
c$$$c       input functions and their derivatives at a collection of points;
c$$$c       the calling syntax for funeval is as follows:
c$$$c
c$$$cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c$$$c
c$$$c       subroutine funeval(x,y,par1,par2,par3,par4,vals,dersx,
c$$$c    1    dersy,ifinvalid)
c$$$c
c$$$c       Return the values of the input functions and their derivatives 
c$$$c       w.r.t. x and y at the point (x,y) in the arrays vals, dersx,
c$$$c       and dersy.  The parameters par? are arbitarily typed 
c$$$c       user-supplied parameters.
c$$$c
c$$$cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c$$$c
c$$$c   nquad - the number of points in the initial quadrature formula
c$$$c   (xs,ys) - the coordinates of the nodes in the initial formula
c$$$c   whts - the initial quadrature weights
c$$$c
c$$$c   funregion - a user-supplied input function which indicates whether
c$$$c       a point is inside of the integration domain or not; the calling
c$$$c       syntax is
c$$$c
c$$$c       subroutine funregion(x,y,isin,par5,par6)
c$$$c
c$$$c       Return 1 in the integer parameter isin if (x,y) is in the domain
c$$$c       of integration and 0 if is not.  Also, the significance assigned
c$$$c       to the point (x,y) wll be d if isin is set to 0.
c$$$c
c$$$c   ngoal - an integer parameter; the routine will terminate when the
c$$$c       number of quadrature nodes reaches this number.
c$$$c
c$$$c   ifaccept - an integer parameter indicating whether quadrature nodes
c$$$c       outside of the domain should be accepted or not;
c$$$c
c$$$c       ifaccept = 0  indicates quadrature nodes outside of the domain
c$$$c                     of integration should not be accepted
c$$$c
c$$$c       ifaccept = 1  accept quadrature nodes outside of the domain of
c$$$c                     integration
c$$$c
c$$$c                        Output Parameters:
c$$$c
c$$$c   nquad - the number of points in the downsampled formula
c$$$c   (xs,y) - the coordinates of the nodes of the downsampled formula
c$$$c   whts - the quadrature weights for the downsampled formula
c$$$c
c$$$        call mach_zero(eps0)
c$$$        eps0=eps0*10
c$$$c
c$$$        maxiters = 8
c$$$        maxsteps = 12
c$$$        dfact    = 0.25d0
c$$$c
c$$$        errl2 = 0
c$$$        do 1000 i=1,nfuns
c$$$        sums(i)=0
c$$$ 1000 continue
c$$$c
c$$$        do 1100 j=1,nquad
c$$$        x   = xs(j)
c$$$        y   = ys(j)
c$$$        wht = whts(j)
c$$$c
c$$$        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,
c$$$     -    ifinvalid)
c$$$        do 1200 i=1,nfuns
c$$$        sums(i) = sums(i) + vals0(i)*wht
c$$$ 1200 continue
c$$$ 1100 continue
c$$$c
c$$$        do 1300 i=1,nfuns
c$$$        errl2 = errl2 + (rints(i) - sums(i))**2
c$$$ 1300 continue
c$$$c     
c$$$        call prin2("in refquad, initial errl2 = *",errl2,1)
c$$$c
c$$$        do 1500 j=1,nquad
c$$$        z0(j)=xs(j)
c$$$        z0(j+nquad)=ys(j)
c$$$        z0(j+2*nquad)=whts(j)
c$$$ 1500 continue
c$$$c
c$$$
c$$$        do 2000 iter=1,maxiters
c$$$c
c$$$        errold=errl2
c$$$c        call prinf("in refquad, iter=*",iter,1)
c$$$c
c$$$        call newton_step(iresult,eps,maxsteps,dfact,nquad,z0,
c$$$     1    nfuns,funeval,par1,par2,par3,par4,rints,errl2,ifaccept,
c$$$     2    funregion,par5,par6,eps0)
c$$$
c$$$c        call prin2("in refquad, errl2=*",errl2,1)
c$$$c
c$$$        if (iresult .ne. 0) return
c$$$        if (errl2 .lt. errold) goto 2000
c$$$        if (errl2 .lt. eps**2) goto 3000
c$$$c
c$$$ 2000 continue
c$$$c
c$$$        iresult=-3
c$$$        return
c$$$ 3000 continue
c$$$c
c$$$        do 3100 i=1,nquad
c$$$        xs(i) = z0(i)
c$$$        ys(i) = z0(i+nquad)
c$$$        whts(i) = z0(i+2*nquad)
c$$$ 3100 continue
c$$$c
c$$$        end


        subroutine compute_signifs(nfuns,funeval,par1,par2,par3,par4,
     -    nquad,xs,ys,whts,signifs,funregion,par5,par6,rints,
     -    ifpositive)
        implicit double precision (a-h,o-z)
        dimension xs(1),ys(1),whts(1),signifs(1),rints(1)
        double precision, allocatable :: vals0(:),dersx0(:),dersy0(:)
        double precision, allocatable :: w2(:)

!        dimension vals0(10 000),dersx0(10 000),dersy0(10 000)
!        dimension w2(10 000)
c
        double precision, allocatable :: df(:,:), a(:,:),w(:)
        double precision, allocatable :: ainv(:,:),ainv2(:,:)
        double precision, allocatable :: b(:),u(:),v(:),df2(:,:)
        double precision, allocatable :: rhs(:)
c
        external funeval,funregion
c
        allocate(vals0(10 000),dersx0(10 000),dersy0(10 000))
        allocate(w2(10 000))

        nlen = nquad*3
c
c       Construct the linearized system ...
c
        allocate ( df(nfuns,nlen), df2(nfuns,nlen), a(nfuns,nfuns) )
        allocate ( ainv(nfuns,nfuns), ainv2(nfuns,nfuns) )
        allocate ( w(16*nfuns*nfuns+nfuns+1500) )
        allocate ( rhs(nfuns) )
c
        do 2200 i=1,nquad
c
        x=xs(i)
        y=ys(i)
        wht=whts(i)
c
        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,
     -    ifinvalid)
c
c       It is unrecoverable to have an invalid point here.
c
        if (ifinvalid .eq. 1) then
        call prinf("in compute_signifs, ifinvalid = *",ifinvalid,1)
        call prin2("x = *",x,1)
        call prin2("y = *",y,1)
        stop
        endif
c
c$$$        call prin2("x=*",x,1)
c$$$        call prin2("y=*",y,1)
c$$$        call prin2("vals0=*",vals0,nfuns)
c$$$        call prin2("dersx0=*",dersx0,nfuns)
c$$$        call prin2("dersy0=*",dersy0,nfuns)
c
        do 2300 j=1,nfuns
        df(j,i)=dersx0(j)*wht
        df(j,i+nquad)=dersy0(j)*wht
        df(j,i+2*nquad)=vals0(j)
 2300 continue
 2200 continue
c     
c       ... and the normal equations.
c
        call gauss_matmul3(nfuns,nfuns,nlen,df,df,a)
c
c       Compute the inverse.
c
        ainv=a
        call orthom(ainv,nfuns,w,cond)
c
c        call prin2("in compute_signifs, cond = *",cond,1)
c
c       Compute the significance of each point.
c
        do 1000 i=1,nquad
c
        x=xs(i)
        y=ys(i)
        wht=whts(i)
c
c       Check that the point is inside the correct region; mark it
c       for removal if not.
c
        call funregion(x,y,isin,par5,par6)
c
        if (isin .eq. 0) then
        signifs(i)=-1.0d0
        goto 1000
        endif
c
c       Check for negative weights.
c
        if (ifpositive .eq. 1 .AND. wht .lt. 0.0d0) then
        signifs(i)=0.0d0
        goto 1000
        endif
c
c       Construct the neutered normal equations by deleting 3 columns
c       of a^-1.
c
        i1 = i
        i2 = i+nquad
        i3 = i+2*nquad
c
        ainv2=ainv
        ifsign=1
        call gauss_smw(ainv2,nfuns,df(1,i1),df(1,i1),w,ifsign,ifsing)
        if (ifsing .ne. 0) then
        signifs(i)=5000
        goto 1000
        endif
c
        call gauss_smw(ainv2,nfuns,df(1,i2),df(1,i2),w,ifsign,ifsing)
        if (ifsing .ne. 0) then
        signifs(i)=5000
        goto 1000
        endif
c
        call gauss_smw(ainv2,nfuns,df(1,i3),df(1,i3),w,ifsign,ifsing)
        if (ifsing .ne. 0) then
        signifs(i)=5000
        goto 1000
        endif
c
        call gaussmove(nfuns*nlen,df,df2)
        do 1100 j=1,nfuns
        df2(j,i1)=0
        df2(j,i2)=0
        df2(j,i3)=0
 1100 continue
c
c       Compute the rhs.
c
        do 1200 j=1,nfuns
        rhs(j)=rints(j)
 1200  continue
c
        do 1300 j=1,nquad
        xx = xs(j)
        yy = ys(j)
        whtt = whts(j)
c
        if ( j .eq. i) goto 1300
        do 1400 jj=1,nfuns
        rhs(jj)=rhs(jj)-whtt*df(jj,nquad*2+j)
 1400 continue
 1300 continue
c
c       Apply the matrices to compute the solution.
c
        call gauss_apply(nfuns,nfuns,ainv2,rhs,w)
        call gauss_applyt(nfuns,nlen,df2,w,w2)
c
        sum = 0
        do 1500 j=1,nlen
        sum=sum+w2(j)**2
 1500 continue
c
        signifs(i)=sum
c
 1000 continue
        end
c
c
c
        subroutine gauss_smw(ainv,n,u,v,work,ifsign,ifsing)
        implicit double precision (a-h,o-z)
c
c       This subroutine applies Sherman-Morrison-Woodbury formula
c       to obtain the rank-1 update of the inverse of the matrix a.
c
c                                          -1
c       More precisely, given the inverse  a  this subroutine 
c       will return either
c
c                         -1
c                (a + uv')  , ifsign=0, or      (1)
c                                       
c                         -1
c                (a - uv')  , ifsign=1,         (2)
c                                       
c     where u and v are two given n-dimensional vectors.
c
c     Please note that u and v are used in the rank-1 update of the 
c     original matrix a, and that all computations in this subroutine
c     are performed with the INVERSE of the matrix a. 
c
c     This is a memory management routine for the routine
c     quaemu0, which performs the actual work.
c
c            Input paramenters:
c
c  a - the matrix dimensioned a(n,n) that contains the inverse of a
c  u,v - the vectors dimensioned u(n) and v(n) 
c
c  ifsign - the parameter that chooses the sign in 
c           Sherman-Morrison-Woodbury formula:
c
c     ifsign=0
c
c              -1    -1    -1              -1   -1     -1
c     (a + uv')   = a   - a   u  (1 + v' a   u)    v' a       (3)
c
c
c     ifsign=1
c
c              -1    -1    -1              -1   -1     -1
c     (a - uv')   = a   + a   u  (1 - v' a   u)    v' a       (4)
c
c            Output parameters:
c
c  a - the rank-1 update of the inverse of a.
c
c            Work arrays:
c
c  work - must be at least 2*n double precision elements long.
c
        double precision ainv(n,n),u(n),v(n),  work(1)
c
        ix=1
        lx=n
c
        iy=ix+lx
        ly=n
c
        call gauss_smw0(ainv,n,u,v,work(ix),work(iy),ifsign,ifsing)
        return
        end
c
c
c
        subroutine gauss_smw0(ainv,n,u,v,x,y,ifsign,ifsing)
        implicit double precision (a-h,o-z)
c
        double precision ainv(n,n),u(n),v(n),x(n),y(n)
c
        call gauss_apply(n,n,ainv,u,x)
        call gauss_applyt(n,n,ainv,v,y)
c
        alpha=0
        do 1200 i=1,n
        alpha=alpha+v(i)*x(i)
 1200   continue
c
        ifsing=0
c
        if (ifsign .eq. 0 .AND. 1+alpha .eq. 0) then
           ifsing=1
           return
        endif
c
        if (ifsign .eq. 1 .AND. 1-alpha .eq. 0) then
           ifsing=1
           return
        endif
c
        if( ifsign.eq.0 ) alpha=+1/(1+alpha)
        if( ifsign.eq.1 ) alpha=-1/(1-alpha)
c
        do 1600 j=1,n
        do 1400 i=1,n
        ainv(j,i)=ainv(j,i)-alpha*x(j)*y(i)
 1400   continue
 1600   continue
c
        return
        end
c
c
c
        subroutine remove_point(iresult,ipt,eps,nfuns,funeval,par1,par2,
     -    par3,par4,nquad,xs,ys,whts,rints,funregion,par5,par6,ifaccept,
     -    eps0)
        implicit double precision (a-h,o-z)
        dimension xs(1),ys(1),whts(1),rints(1)
        double precision, allocatable :: vals0(:),dersx0(:),dersy0(:)
!        dimension vals0(10 000),dersx0(10 000),dersy0(10 000)
        double precision, allocatable :: z0(:)
        external funeval,funregion
c
        allocate(vals0(10 000),dersx0(10 000),dersy0(10 000))

        iresult = 0
c
c
c       Set algorithm parameters.
c
        maxiters = 8
        maxsteps = 8
c
c        maxiters = 30
c        maxsteps = 20
c
        dfact    = 0.25d0
        nextra   = 0
c
        nlen = (nquad)*3-3
c
c       Allocate memory for the Gauss-Newton iterations.
c      
        allocate ( z0(nlen) )
c
c       Remove the specified point from the quadrature.
c
        nn=0
        do 1000 j=1,nquad
        if (ipt .eq. j) goto 1000
        nn=nn+1
        z0(nn)=xs(j)
        z0(nn+nquad-1)=ys(j)
        z0(nn+2*nquad-2)=whts(j)
 1000 continue
c
c       Conduct Newton iterations.
c
c        call prinf("in remove_point, ipt = *",ipt,1)

 1900 continue
        do 2000 iter=1,maxiters       
c        call prinf("iter = *",iter,1)
        call newton_step(iresult,eps,maxsteps,dfact,nquad-1,z0,
     1    nfuns,funeval,par1,par2,par3,par4,rints,errl2,ifaccept,
     2    funregion,par5,par6,eps0)
c        call prinf("iresult=*",iresult,1)
c        call prin2("errl2=*",errl2,1)
c
        if (iresult .ne. 0)  return
c
        if (errl2 .le. (eps**2)) goto 3000
 2000 continue
 2100 continue
        iresult=-1
        goto 9000
 3000 continue
c
c       Perform a few extra newton steps to see if we can refine
c       a bit more.
c
c$$$ 3200 continue
c$$$        errold=errl2
c$$$        call newton_step(jresult,eps,maxsteps,dfact,nquad-1,z0,
c$$$     1    nfuns,funeval,par1,par2,par3,par4,rints,errl2,ifaccept,
c$$$     2    funregion,par5,par6,eps0)
c$$$        call prin2("extra step, errl2=*",errl2,1)
c$$$        if (errl2 .lt. errold/1.1d0) goto 3200
c$$$ 3300 continue
c
c       Copy out the quadrature.
c
        do 5000 j=1,nquad-1
        xs(j)=z0(j)
        ys(j)=z0(j+nquad-1)
        whts(j)=z0(j+2*nquad-2)
 5000 continue
        nquad=nquad-1
c
 9000 continue
        end
c
c
c
        subroutine newton_step(iresult,eps,maxsteps,dfact,
     1    nquad,z0,nfuns,funeval,par1,par2,par3,par4,rints,errl2,
     2    ifaccept,funregion,par5,par6,eps0)
        implicit double precision (a-h,o-z)
        dimension z0(nquad*3),rints(1)
        double precision, allocatable :: vals0(:),dersx0(:),dersy0(:)
        double precision, allocatable :: rnorms(:)

c$$$        dimension vals0(10 000),dersx0(10 000),dersy0(10 000)
c$$$
c$$$        dimension rnorms(10 000)
c
        double precision, allocatable :: df(:,:),rhs(:),z1(:)
        double precision, allocatable :: w(:)
c
        double precision, allocatable :: delta(:)
        double precision, allocatable :: u(:,:),t(:,:),v(:,:)
        external funeval,funregion
c
        allocate(vals0(10 000),dersx0(10 000),dersy0(10 000))
        allocate(rnorms(10 000))
c
c       Conduct a single Gauss-Newton iteration.
c
        iresult = 0
        nlen = nquad*3
c
c       Allocate memory for the operations.
c
        allocate (df(nfuns,nlen), rhs(nfuns), z1(nlen) )
        allocate (w(nfuns*nlen*16+5000),delta(nlen))
c
c        call prinf("in newton_step,nfuns = *",nfuns,1)
c
c       Form the linear system.
c
        do 1000 j=1,nfuns
        rhs(j)=rints(j)
 1000 continue
c
        do 1200 i=1,nquad
        x   = z0(i)
        y   = z0(i+nquad)
        wht = z0(i+2*nquad)
c
        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,
     -   ifinvalid)
c
c       It is unrecoverable to have an invalid point here.
c
        if (ifinvalid .eq. 1) then
        call prinf("in compute_signifs, ifinvalid = *",ifinvalid,1)
        call prin2("x = *",x,1)
        call prin2("y = *",y,1)
        stop
        endif
c
        do 1300 j=1,nfuns
        rhs(j)          = rhs(j)-vals0(j)*wht
        df(j,i)         = dersx0(j)*wht
        df(j,i+nquad)   = dersy0(j)*wht
        df(j,i+2*nquad) = vals0(j)
 1300 continue
 1200 continue
c
c
         errold=0
         do 1400 j=1,nfuns
         errold=errold+rhs(j)**2
 1400 continue
c
         errl2=errold
c
c       Factor df as utv and find a minimum L^2 norm solution.
c
         allocate( u(nfuns,nfuns), t(nfuns,nfuns), v(nfuns,nlen) )
c
         call newtls_factor(eps0,nfuns,nlen,df,u,t,v,krank)
         call newtls_solve(nfuns,nlen,krank,u,t,v,delta,rhs)
c
c        Solve it in a least squares sense to find the Newton direction.
c
c
c       Perform Newton step-length control.
c
c
        do 2000 istep=1,maxsteps
        z1=z0+alpha*delta
        alpha=dfact**(istep-1)
c
        if (ifaccept .eq. 0) then
        do 2050 j=1,nquad
        call funregion(z1(j),z1(j+nquad),isin,par5,par6)
        if(isin .eq. 0) goto 2000
 2050 continue
        endif
c
        do 2100 j=1,nfuns
        rhs(j)=rints(j)
 2100 continue
c
        do 2200 i=1,nquad
c
        x=z1(i)
        y=z1(i+nquad)
        wht=z1(i+2*nquad)
c
        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,
     -    ifinvalid)
c
c       If we get an invalid point here, take a smaller step.
c
        if (ifinvalid .eq. 1) then
        goto 2000
        endif
c
        do 2300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
 2300 continue
 2200 continue
c
        errnew = 0
        do 2400 j=1,nfuns
        errnew=errnew+rhs(j)**2
 2400 continue
c
        if (errnew .lt. errold) goto 3000
c
 2000 continue     
c
c       We could not improve the accuracy of the formula by a sufficient
c       amount.
c
        iresult = -1
        goto 9000
 3000 continue
c
c       Accept the new quadrature and return.
c
        errl2=errnew
        z0=z1
 9000 continue
c
        end

        subroutine newton_step2(iresult,eps,maxsteps,dfact,
     1    nquad,z0,nfuns,funeval,par1,par2,par3,par4,rints,errl2,
     2    ifaccept,funregion,par5,par6,eps0)

        implicit double precision (a-h,o-z)
        dimension z0(nquad*3),rints(1)
        dimension vals0(1000),dersx0(1000),dersy0(1000),rnorms(10 000)
c
        double precision, allocatable :: df(:,:),rhs(:),z1(:)
        double precision, allocatable :: w(:)
c
        double precision, allocatable :: delta(:)
        double precision, allocatable :: u(:,:),t(:,:),v(:,:)
        external funeval,funregion
c
c       Conduct a single Gauss-Newton iteration.
c
        iresult = 0
        nlen = nquad*3
c
c       Allocate memory for the operations.
c
        allocate (df(nfuns,nlen), rhs(nfuns), z1(nlen) )
        allocate (w(nfuns*nlen*16+5000),delta(nlen))
c
c       Form the linear system.
c
        do 1000 j=1,nfuns
        rhs(j)=rints(j)
 1000 continue
c
        do 1200 i=1,nquad
        x  =z0(i)
        y  =z0(i+nquad)
        wht=z0(i+2*nquad)
c
        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,
     -    ifinvalid)
c
c       We shouldn't get an invalid point here.
c
        if (ifinvalid .eq. 1) then
        iresult = 1024
        return
        endif
c
        do 1300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
        df(j,i)=dersx0(j)*wht
        df(j,i+nquad)=dersy0(j)*wht
        df(j,i+2*nquad)=vals0(j)
 1300 continue
 1200 continue
c
         errold=0
         do 1400 j=1,nfuns
         errold=errold+rhs(j)**2
 1400 continue
c
c         call prin2("rhs=*",rhs,nfuns)
c         call prin2("errold=*",errold,1)
c
c
         errl2=errold
c
c       Factor df as utv and find a minimum L^2 norm solution.
c
c         if (ifinit .eq. 0) then
c
         allocate( u(nfuns,nfuns), t(nfuns,nfuns),v(nfuns,nlen) )
         call newtls_factor(eps0,nfuns,nlen,df,u,t,v,krank)
         call newtls_solve(eps0,nfuns,nlen,krank,u,t,v,delta,rhs)
c
c         else
c         call newtls_solve2(nfuns,nlen,df,v,delta,rhs)
c         endif
c
c         call prin2("delta=*",delta,nlen)
c
c        Solve it in a least squares sense to find the Newton direction.
c
c$$$         call clotatim(t1)
c$$$        call mach_zero(eps0)
c$$$        eps0=eps0*2
c$$$        k=1
c$$$        ifcheck=0
c$$$        call nrleamatll(df,nfuns,nlen,k,rhs,delta,eps0,krank,
c$$$     1    rnorms,w,ifcheck,errl2,errmax)
c$$$         call clotatim(t2)
c$$$c
c         call prin2("delta=*",delta,nlen)
c
c        call prinf("krank=*",krank,1)
c        call prinf("nfuns=*",nfuns,1)
c        call prin2("rnorms=*",rnorms,krank)
c        call prin2("errl2=*",errl2,1)        
c
c       Perform Newton step-length control.
c        
        alpha=1.0d0
c
        do 2000 istep=1,maxsteps
        z1=z0+alpha*delta
        alpha=alpha*dfact
c
        if (ifaccept .eq. 0) then
        do 2050 j=1,nquad
        x=z1(j)
        y=z1(j+nquad)
        call funregion(x,y,isin,par5,par6)
        if (isin .eq. 0) goto 2000
 2050 continue
        endif
c
        do 2100 j=1,nfuns
        rhs(j)=rints(j)
 2100 continue
c
        do 2200 i=1,nquad
        x=z1(i)
        y=z1(i+nquad)
        wht=z1(i+2*nquad)
c
        ifders=0
        call funeval(x,y,par1,par2,par3,par4,vals0,dersx0,dersy0,ifders,
     -   ifinvalid)
        if (ifinvalid .eq. 1) goto 2000
c
        do 2300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
 2300 continue
 2200 continue
c
        errnew = 0
        do 2400 j=1,nfuns
        errnew=errnew+rhs(j)**2
 2400 continue
c
        if (errnew .lt. errold) goto 3000
c
 2000 continue     
c
c       We could not improve the accuracy of the formula.
c
        iresult = -1
        goto 9000
 3000 continue
c
c       Accept the new quadrature and return.
c
        errl2=errnew
        z0=z1
 9000 continue
        end


        subroutine insort4(k,a,b,c,d)
        implicit double precision (a-h,o-z)
        dimension a(1),b(1),c(1),d(1)
c
        do 1000 i=2,k
        val=a(i)
        val2=b(i)
        val3=c(i)
        val4=d(i)
        j=i-1
        do 1100 while (j .ge. 1 .AND. a(j) .gt. val) 
        a(j+1)=a(j)
        b(j+1)=b(j)
        c(j+1)=c(j)
        d(j+1)=d(j)
        j=j-1
 1100 continue
        a(j+1)=val
        b(j+1)=val2
        c(j+1)=val3
        d(j+1)=val4
 1000 continue
        end
c
c
c
        subroutine gauss_apply(n,m,a,x,y)
        implicit double precision (a-h,o-z)
        dimension a(n,m),x(m),y(n)
c
        do 1000 i=1,n
        sum=0
        do 1100 j=1,m
        sum=sum+a(i,j)*x(j)
 1100 continue
        y(i)=sum
 1000 continue
        end
c
c
c
        subroutine gauss_applyt(n,m,u,x,y)
        implicit double precision (a-h,o-z)
        dimension u(n,m),x(n),y(m)
c
        do 1000 i=1,m
        sum=0
        do 1100 j=1,n
        sum=sum+u(j,i)*x(j)
 1100 continue
        y(i)=sum
 1000 continue
        end
c
c
c
        subroutine gauss_matmul2(n,m,k,a,b,c)
        implicit double precision (a-h,o-z)
        dimension c(n,m),a(k,n),b(k,m)
c
c       c = a^*b
c
        do 1000 i=1,n
        do 1100 j=1,m
        sum=0
        do 1200 l=1,k
        sum=sum+a(l,i)*b(l,j)
 1200 continue
        c(i,j)=sum
 1100 continue
 1000 continue
        end
c
c
c
        subroutine gauss_matmul3(n,m,k,a,b,c)
        implicit double precision (a-h,o-z)
        dimension c(n,m),a(n,k),b(m,k)
c
        do 1000 i=1,n
        do 1100 j=1,m
        sum=0
        do 1200 l=1,k
        sum=sum+a(i,l)*b(j,l)
 1200 continue
        c(i,j)=sum
 1100 continue
 1000 continue
        end
c
c
c
        subroutine gaussmove(k,a,b)
        implicit double precision (a-h,o-z)
        dimension a(1),b(1)
        do 1000 j=1,k
        b(j)=a(j)
 1000 continue
        end
