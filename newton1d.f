c
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       This is the end of the debugging code and beginning of the code
c       proper.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       This file contains code for constructing quadratures for
c       a collection of functions f_1,...,f_N given over an 
c       interval.  It operates by solving the system of equations
c
c          \sum_l f_j(x_l) w_l = \int f_j(x) dx    j=1,...,N            (1)
c              
c       for the weights and/or nodes of a quadrature.
c
c       In the case of the routine chebquad, a basic solution of the
c       *linear* system obtained by letting the x_l in (1) be the
c       nodes of an oversamped quadrature formula integrating the 
c       functions f_j is constructed in order to compute an N-point
c       quadrature for the f_j.
c
c       In the case of gaussquad, the nonlinear system (1) is solved
c       by reducing an existing quadrature formula for the f_j point-
c       by-point.  In particular, given an existing M-point formula,
c       a quadrature node is (carefully) selected for removal and the
c       resulting (M-1)-point formula is used as an initial value
c       for Gauss-Newton type iterations.  The process is repeated
c       until an accurate formula can no longer be obtained.
c
c       The input to the user-callable procedures is in each case an
c       external subroutine which returns the values and possibly the
c       first derivatives of the input functions at a given point.
c
c       Notes:
c
c    1. The quadratures generated by these routines are not 
c       guaranteed to have positive weights or interior nodes, but
c       some care is taken to "encourage" them to do so.
c
c    2. The evaluation of input functions is by far the most time-
c       consuming operation peformed by the code.  The user is 
c       urged to take care in generating efficient representations
c       for the input functions.
c
c    3. If the input functions are not orthogonal or nearly so, then
c       the systems of equations solved by these routines can become
c       poorly conditioned.  Similarly, if the "scales" of the
c       input functions vary widely, then the routine will generally
c       fail or perform suboptimally.  It is highly suggested that 
c       orthonormal input functions be used.
c    
c       The following subroutines are user-callable:
c
c   chebquad - given a collection of k orthonormal input functions 
c      represented as coefficient expansions and a preexisting 
c      quadrature integrating products of the input functions, 
c      construct a k-point quadrature
c
c   chebquad2 - given the values of a collection of k orthonormal 
c      input functions at the nodes of a quadrature integrating
c      their products, construct a k-point quadrature integrating
c      them

c   gaussquad - further downsample an existing quadrature for a 
c      collection of orthonormal input functions by applying 
c      Gauss-Newton iteratons to the obvious nonlinear system of 
c      equations to reduce the quadrature point-by-point.
c
c   refquad - refine an existing quadrature formula; that is, given
c      quadrature for a collection of functions perform Newton
c      iterations so as to improve the accuracy
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
        subroutine chebquad(nfuns,funeval,par1,par2,par3,par4,
     1    nquad0,xs0,whts0,nquad,xs,whts,rints)
        implicit double precision (a-h,o-z)
        dimension xs0(1),whts0(1),xs(1),whts(1),rints(1)
        double precision, allocatable :: rnorms(:),sol(:)
        integer, allocatable :: ipivs(:)
c
        double precision, allocatable :: vals(:,:),a(:,:),b(:,:)
        double precision, allocatable :: vals0(:),ders0(:)

        external funeval
c
c       Construct a k-point quadrature for a collection of k orthonormal
c       functions given an existing n-point quadrature integrating their
c       products.
c
c       This procedure operates by producing a basic solution to the
c       obvious linear system of equations.  Note the resulting 
c       quadrature will have interior nodes but is not guaranteed to 
c       have positive weights.
c
c                          Input Parameters:
c
c   nfuns - the number of input functions in the orthonormal collection
c
c   funeval - a user-supplied external subroutine for evaluating the
c       input functions and their derivatives at a collection of points;
c       the calling syntax for funeval is as follows:
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       subroutine funeval(x,par1,par2,par3,par4,vals,ders,ifders)
c
c       Return the values of the input functions and their derivatives
c       at the point (x,y) in the arrays vals and ders.  The parameters 
c       par? are arbitarily typed user-supplied parameters.
c
c       If the ifders parameters is set to 0 the derivatives need
c       not be computed.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c   nquad0 - the number of points in the initial quadrature formula
c   xs0 - the coordinates of the nodes in the initial formula
c   whts0 - the initial quadrature weights
c
c                        Output Parameters:
c
c   nquad - the number of points in the downsampled formula
c   xs - the coordinates of the nodes of the downsampled formula
c   whts - the quadrature weights for the downsampled formula
c
c   rints - upon return, this user-supplied array will contain the
c       integrals of the input functions as computed using the 
c       initial quadrature.
c
c       Allocate memory for the procedure.
c
        allocate ( vals(nquad0,nfuns), a(nfuns,nquad0) )
        allocate ( b(nfuns,nfuns) )
        allocate(rnorms(100000),ipivs(100000),sol(100000))
        allocate(vals0(10000),ders0(10000))

!        dimension rnorms(100 000),ipivs(200 000),sol(10000)
c
c       Evaluate the functions at the quadrature nodes.
c
        do 1000 i=1,nquad0
c
        x=xs0(i)
c
        ifders=0
        call funeval(x,par1,par2,par3,par4,vals0,ders0,ifders)
        do 1100 j=1,nfuns
        vals(i,j)=vals0(j)
 1100 continue
 1000 continue
c
c
c
c       Compute the integrals of the functions.
c
        do 1200 j=1,nfuns
        sum=0
        do 1300 i=1,nquad0
        wht=whts0(i)
        sum=sum+vals(i,j)*wht
 1300 continue
        rints(j)=sum
        sol(j)=sum
 1200 continue
c
        call prin2("in chebquad, rints = *",rints,nfuns)
c

c
c       Use GS to pick quadrature nodes.
c
        do 2000 i=1,nquad0
        wht=whts0(i)
        do 2100 j=1,nfuns
        a(j,i)=vals(i,j)*sqrt(wht)
 2100 continue
 2000 continue
c
        call gspiv2(a,nfuns,nquad0,rnorms,ipivs)
c
c        call prin2("in chebquad, rnorms=*",rnorms,nfuns)
c        call prinf("in chebquad, ipivs=*",ipivs,nfuns)
c
c       Solve a linear system in order to construct weights.
c
        do 3000 j=1,nfuns
        do 3100 i=1,nfuns
        ii=ipivs(i)
        b(j,i)=vals(ii,j)*sqrt(whts0(ii))
 3100 continue
 3000 continue
c
c
        call qrsolv(b,nfuns,sol,rcond)
        call prin2("rcond=*",rcond,1)

c       
c       Compute the quadrature.
c
c
        nquad = nfuns
        do 4000 j=1,nquad
        jj=ipivs(j)
        xs(j) = xs0(jj)
        whts(j) = sol(j)*sqrt(whts0(jj))
 4000 continue
c
c
c       Sort the quadrature.
c
        call insort2(nquad,xs,whts)
c
        call prinf("in chebquad, nquad=*",nquad,1)
        call prin2("in chebquad, xs=*",xs,nquad)
        call prin2("in chebquad, whts=*",whts,nquad)
        end



        subroutine gaussquad(eps,nfuns,rints,funeval,par1,par2,par3,
     1    par4,nquad,xs,whts,a,b,ngoal,ifaccept)
        implicit double precision (a-h,o-z)
        dimension xs(1),whts(1),rints(1)
        double precision, allocatable :: vals0(:),ders(:),signifs(:)
        external funeval
c
c       Reduce an existing quadrature formula for a collection of 
c       functions point-by-point by solving the obvious nonlinear
c       system of equations via Gauss-Newton type iteration.       
c
c                           Input Parameters:
c
c   eps - the precision for the resulting quadrature
c   nfuns - the number of input functions in the orthonormal collection
c   rints - the integrals of the input functions; typically, this is 
c       computed by chebquad and passed to gaussquad
c
c   funeval - a user-supplied external subroutine for evaluating the
c       input functions and their derivatives at a collection of points;
c       the calling syntax for funeval is as follows:
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       subroutine funeval(x,par1,par2,par3,par4,vals,ders,ifders)
c
c       Return the values of the input functions and their derivatives 
c       w.r.t. x and y at the point (x,y) in the arrays vals, dersx,
c       and dersy.  The parameters par? are arbitarily typed 
c       user-supplied parameters.
c
c       If the ifders parameters is set to 0 the derivatives need
c       not be computed.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c   nquad - the number of points in the initial quadrature formula
c   xs - the coordinates of the nodes in the initial formula
c   whts - the initial quadrature weights
c
c   ngoal - an integer parameter; the routine will terminate when the
c       number of quadrature nodes reaches this number.
c
c   ifaccept - an integer parameter indicating whether quadrature nodes
c       outside of the domain should be accepted or not;
c
c       ifaccept = 0  indicates quadrature nodes outside of the domain
c                     of integration should not be accepted
c
c       ifaccept = 1  accept quadrature nodes outside of the domain of
c                     integration
c
c                        Output Parameters:
c
c   nquad - the number of points in the downsampled formula
c   xs - the coordinates of the nodes of the downsampled formula
c   whts - the quadrature weights for the downsampled formula
c
        allocate(vals0(100 000),ders(100 000),signifs(1 000 000))
        call mach_zero(eps0)
        eps0=eps0*10
c
c       Remove points, one-by-one (if possible).
c
 2000 continue
c
        if (nquad .eq. ngoal) return
c
c       Compute signifigances for the points and reorder them.
c

        call compute_signifs(nfuns,funeval,par1,par2,par3,par4,
     1    nquad,xs,whts,signifs,a,b,rints)
c
        call insort3(nquad,signifs,xs,whts)

c
        call prinf("nquad=*",nquad,1)
        call prin2("xs=*",xs,nquad)
        call prin2("whts=*",whts,nquad)
        call prin2("signifs=*",signifs,nquad)
c
c       Try to remove each point.
c        
        do 2100 ipt=1,nquad
c        call prinf("ipt = *",ipt,1)
        call remove_point(iresult,ipt,eps,nfuns,funeval,par1,
     1    par2,par3,par4,nquad,xs,whts,rints,a,b,ifaccept,eps0)
c        call prinf("after remove_point, iresult = *",iresult,1)
        if (iresult .eq. 0) goto 2000
 2100 continue
c 3000 continue
c
c       Otherwise, we are done.
c
        end
c
c
c
        subroutine refquad(iresult,eps,nfuns,rints,funeval,par1,par2,
     1    par3,par4,nquad,xs,whts,a,b,ifaccept,v,ifinit)
        implicit double precision (a-h,o-z)
        dimension xs(1),whts(1),rints(1),z0(2*nquad)
        double precision, allocatable :: vals0(:),ders0(:),sums(:)
        dimension v(1)
        external funeval
c
c       Reduce an existing quadrature formula for a collection of 
c       functions point-by-point by solving the obvious nonlinear
c       system of equations via Gauss-Newton type iteration.       
c
c                           Input Parameters:
c
c   eps - the precision for the resulting quadrature
c   nfuns - the number of input functions in the orthonormal collection
c   rints - the integrals of the input functions; typically, this is 
c       computed by chebquad and passed to gaussquad
c
c   funeval - a user-supplied external subroutine for evaluating the
c       input functions and their derivatives at a collection of points;
c       the calling syntax for funeval is as follows:
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       subroutine funeval(x,par1,par2,par3,par4,vals,dersx,
c    1    dersy,ifders)
c
c       Return the values of the input functions and their derivatives 
c       w.r.t. x and y at the point (x,y) in the arrays vals, dersx,
c       and dersy.  The parameters par? are arbitarily typed 
c       user-supplied parameters.
c
c       If the ifders parameters is set to 0 the derivatives need
c       not be computed.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c   nquad - the number of points in the initial quadrature formula
c   (xs,ys) - the coordinates of the nodes in the initial formula
c   whts - the initial quadrature weights
c
c
c   ngoal - an integer parameter; the routine will terminate when the
c       number of quadrature nodes reaches this number.
c
c   ifaccept - an integer parameter indicating whether quadrature nodes
c       outside of the domain should be accepted or not;
c
c       ifaccept = 0  indicates quadrature nodes outside of the domain
c                     of integration should not be accepted
c
c       ifaccept = 1  accept quadrature nodes outside of the domain of
c                     integration
c
c                        Output Parameters:
c
c   nquad - the number of points in the downsampled formula
c   (xs,y) - the coordinates of the nodes of the downsampled formula
c   whts - the quadrature weights for the downsampled formula
c
        allocate(vals0(10000),ders0(10000),sums(10000))

c
        maxiters = 30
        maxsteps = 30
c
        dfact    = 0.5d0
c
        do 1000 j=1,nquad
        z0(j)=xs(j)
        z0(j+nquad)=whts(j)
 1000 continue
c
        do 2000 iter=1,maxiters
c
        call newton_step2(iresult,eps,maxsteps,dfact,
     1    nquad,z0,nfuns,funeval,par1,par2,par3,par4,rints,errl2,
     2    ifaccept,a,b,v,ifinit)
c
c        call prin2("errl2=*",errl2,1)
        if (errl2 .lt. eps**2) goto 3000
        if (iresult .ne. 0) return
c
 2000 continue
c
        iresult=-3
        return
 3000 continue
c$$$c
c$$$ 3200 continue
c$$$        errold=errl2
c$$$        call newton_step(jresult,eps,maxsteps,dfact,nquad,z0,
c$$$     1    nfuns,funeval,par1,par2,par3,par4,rints,errl2,ifaccept,
c$$$     2    a,b)
c$$$c
c$$$        call prin2("errl2=*",errl2,1)
c$$$        if (errl2 .lt. errold/1.0d0) goto 3200
c
        do 3100 i=1,nquad
        xs(i) = z0(i)
        whts(i) = z0(i+nquad)
 3100 continue
c
        end
c
c
c
        subroutine compute_signifs(nfuns,funeval,par1,par2,par3,par4,
     1    nquad,xs,whts,signifs,aa,bb,rints)
        implicit double precision (a-h,o-z)
        dimension xs(1),ys(1),whts(1),signifs(1),rints(1)
c
        double precision, allocatable :: df(:,:), a(:,:),w(:),w2(:)
        double precision, allocatable :: ainv(:,:),ainv2(:,:)
        double precision, allocatable :: b(:),u(:),v(:),df2(:,:)
        double precision, allocatable :: rhs(:)
c
        double precision, allocatable :: vals0(:),ders0(:)
c
        external funeval
c
        allocate(vals0(10 000),ders0(10 000),w2(10000))
c
        nlen = nquad*2
c
c       Construct the linearized system ...
c
        allocate ( df(nfuns,nlen), df2(nfuns,nlen), a(nfuns,nfuns) )
        allocate ( ainv(nfuns,nfuns), ainv2(nfuns,nfuns) )
        allocate ( w(nfuns**2+nfuns+5000) )
        allocate ( rhs(nfuns) )
c
        do 2200 i=1,nquad
c
        x=xs(i)
        wht=whts(i)
c
        ifders=1
        call funeval(x,par1,par2,par3,par4,vals0,ders0,ifders)
c
        do 2300 j=1,nfuns
        df(j,i)=ders0(j)*wht
        df(j,i+nquad)=vals0(j)
 2300 continue
 2200 continue        
c     
c       ... and the normal equations.
c
        call gauss_matmul3(nfuns,nfuns,nlen,df,df,a)
c
c       Compute the inverse.
c
        ainv=a
        call orthom(ainv,nfuns,w,cond)
c        call prin2("in compute_signifs, cond = *",cond,1)
c
c       Compute the significance of each point.
c
        do 1000 i=1,nquad
c
        x=xs(i)
        wht=whts(i)
c
c       Check that the point is inside the correct region; mark it
c       for removal if not.
c
c$$$        if (x .lt. aa .OR. x .gt. bb) then
c$$$        signifs(i)=-1
c$$$        goto 1000
c$$$        endif
c$$$c
c$$$        if (wht .lt. 0) then
c$$$        signifs(i)=0
c$$$        goto 1000
c$$$        endif

c
c       Construct the neutered normal equations by deleting 2 columns
c       of a^-1.
c
        i1 = i
        i2 = i+nquad
c
        ainv2=ainv
        ifsign=1
        call gauss_smw(ainv2,nfuns,df(1,i1),df(1,i1),w,ifsign,ifsing)
        if (ifsing .ne. 0) then
        signifs(i)=5000
        goto 1000
        endif
c
        call gauss_smw(ainv2,nfuns,df(1,i2),df(1,i2),w,ifsign,ifsing)
        if (ifsing .ne. 0) then
        signifs(i)=5000
        goto 1000
        endif
c
        call gaussmove(nfuns*nlen,df,df2)
        do 1100 j=1,nfuns
        df2(j,i1)=0
        df2(j,i2)=0
 1100 continue
c
c       Compute the rhs.
c
        do 1200 j=1,nfuns
        rhs(j)=rints(j)
 1200  continue
c
        do 1300 j=1,nquad
        xx = xs(j)
        whtt = whts(j)
c
        if ( j .eq. i) goto 1300
        do 1400 jj=1,nfuns
        rhs(jj)=rhs(jj)-whtt*df(jj,nquad+j)
 1400 continue
 1300 continue
c
c       Apply the matrices to compute the solution.
c
        call gauss_apply(nfuns,nfuns,ainv2,rhs,w)
        call gauss_applyt(nfuns,nlen,df2,w,w2)
        sum = 0
        do 1500 j=1,nlen
        sum=sum+w2(j)**2
 1500 continue
c
        signifs(i)=sum
c
 1000 continue
        end
c
c
c
        subroutine gauss_smw(ainv,n,u,v,work,ifsign,ifsing)
        implicit double precision (a-h,o-z)
c
c       This subroutine applies Sherman-Morrison-Woodbury formula
c       to obtain the rank-1 update of the inverse of the matrix a.
c
c                                          -1
c       More precisely, given the inverse  a  this subroutine 
c       will return either
c
c                         -1
c                (a + uv')  , ifsign=0, or      (1)
c                                       
c                         -1
c                (a - uv')  , ifsign=1,         (2)
c                                       
c     where u and v are two given n-dimensional vectors.
c
c     Please note that u and v are used in the rank-1 update of the 
c     original matrix a, and that all computations in this subroutine
c     are performed with the INVERSE of the matrix a. 
c
c     This is a memory management routine for the routine
c     quaemu0, which performs the actual work.
c
c            Input paramenters:
c
c  a - the matrix dimensioned a(n,n) that contains the inverse of a
c  u,v - the vectors dimensioned u(n) and v(n) 
c
c  ifsign - the parameter that chooses the sign in 
c           Sherman-Morrison-Woodbury formula:
c
c     ifsign=0
c
c              -1    -1    -1              -1   -1     -1
c     (a + uv')   = a   - a   u  (1 + v' a   u)    v' a       (3)
c
c
c     ifsign=1
c
c              -1    -1    -1              -1   -1     -1
c     (a - uv')   = a   + a   u  (1 - v' a   u)    v' a       (4)
c
c            Output parameters:
c
c  a - the rank-1 update of the inverse of a.
c
c            Work arrays:
c
c  work - must be at least 2*n double precision elements long.
c
        double precision ainv(n,n),u(n),v(n),  work(1)
c
        ix=1
        lx=n
c
        iy=ix+lx
        ly=n
c
        call gauss_smw0(ainv,n,u,v,work(ix),work(iy),ifsign,ifsing)
        return
        end
c
c
c
        subroutine gauss_smw0(ainv,n,u,v,x,y,ifsign,ifsing)
        implicit double precision (a-h,o-z)
        double precision ainv(n,n),u(n),v(n),x(n),y(n)
c
        call gauss_apply(n,n,ainv,u,x)
        call gauss_applyt(n,n,ainv,v,y)
c
        alpha=0
        do 1200 i=1,n
        alpha=alpha+v(i)*x(i)
 1200   continue
c
        ifsing=0
c
        if (ifsign .eq. 0 .AND. 1+alpha .eq. 0) then
           ifsing=1
           return
        endif
c
        if (ifsign .eq. 1 .AND. 1-alpha .eq. 0) then
           ifsing=1
           return
        endif
c
        if( ifsign.eq.0 ) alpha=+1/(1+alpha)
        if( ifsign.eq.1 ) alpha=-1/(1-alpha)
c
        do 1600 j=1,n
        do 1400 i=1,n
        ainv(j,i)=ainv(j,i)-alpha*x(j)*y(i)
 1400   continue
 1600   continue
c
        return
        end
c
c
c
        subroutine remove_point(iresult,ipt,eps,nfuns,funeval,par1,par2,
     1    par3,par4,nquad,xs,whts,rints,a,b,ifaccept,eps0)
        implicit double precision (a-h,o-z)
        dimension xs(1),whts(1),rints(1)
        double precision, allocatable :: z0(:)
c        
        external funeval
c
        iresult = 0
c
c       Set algorithm parameters.
c
        maxiters = 20
        maxsteps = 30
c
        dfact    = 0.50d0
        nextra   = 0
c
        nlen = (nquad-1)*2
c
c       Allocate memory for the Gauss-Newton iterations.
c      
        allocate ( z0(nlen) )
c
c       Remove the specified point from the quadrature.
c
        nn=0
        do 1000 j=1,nquad
        if (ipt .eq. j) goto 1000
        nn=nn+1
        z0(nn)=xs(j)
        z0(nn+nquad-1)=whts(j)
 1000 continue
c
c       Conduct Newton iterations.
c
 1900 continue
        do 2000 iter=1,maxiters       
c
c        call prinf("iter=*",iter,1)
        call newton_step(iresult,eps,maxsteps,dfact,nquad-1,z0,
     1    nfuns,funeval,par1,par2,par3,par4,rints,errl2,ifaccept,
     2    a,b,eps0)
c
        call prin2("errl2=*",errl2,1)
        if (errl2 .le. eps**2) goto 3000
        if (iresult .ne. 0)  return
 2000 continue
 2100 continue
        iresult=-1
        goto 9000
 3000 continue
c
c       Perform a few extra newton steps to see if we can refine
c       a bit more.
c
 3200 continue
        errold=errl2
        call newton_step(jresult,eps,maxsteps,dfact,nquad-1,z0,
     1    nfuns,funeval,par1,par2,par3,par4,rints,errl2,ifaccept,
     2    a,b,eps0)
        call prin2("extra step, errl2 = *",errl2,1)
        if (errl2 .lt. errold/10.0d0) goto 3200
c
c       Copy out the quadrature.
c
        do 5000 j=1,nquad-1
        xs(j)=z0(j)
        whts(j)=z0(j+nquad-1)
 5000 continue
        nquad=nquad-1
c
 9000 continue
        end
c
c
c
        subroutine newton_step2(iresult,eps,maxsteps,dfact,
     1    nquad,z0,nfuns,funeval,par1,par2,par3,par4,rints,errl2,
     2    ifaccept,a,b,v,ifinit)
        implicit double precision (a-h,o-z)
        dimension z0(nquad*3),rints(1),v(1)
c
        double precision, allocatable :: vals0(:),ders0(:),rnorms(:)
c
        double precision, allocatable :: df(:,:),rhs(:),z1(:)
        double precision, allocatable :: w(:)
c
        double precision, allocatable :: delta(:)
        double precision, allocatable :: u(:,:),t(:,:)
        external funeval
c
c       Conduct a single Gauss-Newton iteration.
c
        allocate(vals0(1000),ders0(10000),rnorms(10000))

        iresult = 0
        nlen = nquad*2
c
c       Allocate memory for the operations.
c
        allocate (df(nfuns,nlen), rhs(nfuns), z1(nlen) )
        allocate (w(nfuns*nlen*16+5000),delta(nlen))
c
c       Form the linear system.
c
        do 1000 j=1,nfuns
        rhs(j)=rints(j)
 1000 continue
c
        do 1200 i=1,nquad
        x=z0(i)
        wht=z0(i+nquad)
c
        ifders=1
        call funeval(x,par1,par2,par3,par4,vals0,ders0,ifders)
c
        do 1300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
        df(j,i)=ders0(j)*wht
        df(j,i+nquad)=vals0(j)
 1300 continue
 1200 continue
c
         errold=0
         do 1400 j=1,nfuns
         errold=errold+rhs(j)**2
 1400 continue
c
         errl2=errold
c
c       Factor df as utv and find a minimum L^2 norm solution.
c
         if (ifinit .eq. 0) then
         allocate( u(nfuns,nfuns), t(nfuns,nfuns) )
         call newtls_factor(nfuns,nlen,df,u,t,v,krank)
         call newtls_solve(nfuns,nlen,krank,u,t,v,delta,rhs)
         else
            stop
c         call newtls_solve2(nfuns,nlen,df,v,delta,rhs)
         endif
c
c
c       Perform Newton step-length control.
c        
        alpha=1.0d0
c
        do 2000 istep=1,maxsteps
        z1=z0+alpha*delta
        alpha=alpha*dfact
c
        if (ifaccept .eq. 0) then
        x=z1(j)
        if (x .lt. a .OR. x .gt. b) goto 2000
        endif
c
        do 2100 j=1,nfuns
        rhs(j)=rints(j)
 2100 continue
c
        do 2200 i=1,nquad
        x=z1(i)
        wht=z1(i+nquad)
c
        ifders=0
        call funeval(x,par1,par2,par3,par4,vals0,dersx0,dersy0,ifders)
c
        do 2300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
 2300 continue
 2200 continue
c
        errnew = 0
        do 2400 j=1,nfuns
        errnew=errnew+rhs(j)**2
 2400 continue
c
        if (errnew .lt. errold) goto 3000
c
 2000 continue     
c
c       We could not improve the accuracy of the formula.
c
        iresult = -1
        goto 9000
 3000 continue
c
c       Accept the new quadrature and return.
c
        errl2=errnew
        z0=z1
 9000 continue
        end

c
c
c
        subroutine newton_step(iresult,eps,maxsteps,dfact,
     1    nquad,z0,nfuns,funeval,par1,par2,par3,par4,rints,errl2,
     2    ifaccept,a,b,eps0)
        implicit double precision (a-h,o-z)
        dimension z0(nquad*2),rints(1)
c
        double precision, allocatable :: vals0(:),ders0(:),rnorms(:)
        double precision, allocatable :: df(:,:),rhs(:),z1(:)
        double precision, allocatable :: w(:),u(:,:),t(:,:),v(:,:)
c
        double precision, allocatable :: delta(:)
        external funeval
c
        allocate(vals0(100000),ders0(100000),rnorms(10000))
c
c       Conduct a single Gauss-Newton iteration.
c
        iresult = 0
        nlen = nquad*2
c
c       Allocate memory for the operations.
c
        allocate (df(nfuns,nlen), rhs(nfuns), z1(nlen) )
        allocate (w(nfuns*nlen*16+5000),delta(nlen))
c
c       Form the linear system.
c
        do 1000 j=1,nfuns
        rhs(j)=rints(j)
 1000 continue
c
        do 1200 i=1,nquad
        x=z0(i)
        wht=z0(i+nquad)
c
        ifders=1
        call funeval(x,par1,par2,par3,par4,vals0,ders0,ifders)
c
        do 1300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
        df(j,i)=ders0(j)*wht
        df(j,i+nquad)=vals0(j)
 1300 continue
 1200 continue
c
         errold=0
         do 1400 j=1,nfuns
         errold=errold+rhs(j)**2
 1400 continue
c
         errl2=errold
c
c        Solve it in a least squares sense to find the Newton direction.
c
         allocate( u(nfuns,nfuns), t(nfuns,nfuns), v(nfuns,nlen) )
c
         call newtls_factor(eps0,nfuns,nlen,df,u,t,v,krank)
         call newtls_solve(nfuns,nlen,krank,u,t,v,delta,rhs)
c
c       Perform Newton step-length control.
c        
        alpha=1.0d0
c
        do 2000 istep=1,maxsteps
        z1=z0+alpha*delta
        alpha=alpha*dfact
c
        if (ifaccept .eq. 0) then
        do 2050 j=1,nquad
        x=z1(j)
        if (x .lt. a .OR. x .gt. b) goto 2000
 2050 continue
        endif
c
        do 2100 j=1,nfuns
        rhs(j)=rints(j)
 2100 continue
c
        do 2200 i=1,nquad
        x=z1(i)
        wht=z1(i+nquad)
c
        ifders=0
        call funeval(x,par1,par2,par3,par4,vals0,ders0,ifders)
c
        do 2300 j=1,nfuns
        rhs(j)=rhs(j)-vals0(j)*wht
 2300 continue
 2200 continue
c
        errnew = 0
        do 2400 j=1,nfuns
        errnew=errnew+rhs(j)**2
 2400 continue
c
        if (errnew .lt. errold*.9d0) goto 3000
c
 2000 continue     
c
c       We could not improve the accuracy of the formula.
c
        iresult = -1
        goto 9000
 3000 continue
c
c       Accept the new quadrature and return.
c
        errl2=errnew
        z0=z1
 9000 continue
        end
c
c
c
        subroutine insort2(k,a,b)
        implicit double precision (a-h,o-z)
        dimension a(1),b(1)
c
        do 1000 i=2,k
        val=a(i)
        val2=b(i)
        j=i-1
        do 1100 while (j .ge. 1 .AND. a(j) .gt. val) 
        a(j+1)=a(j)
        b(j+1)=b(j)
        j=j-1
 1100 continue
        a(j+1)=val
        b(j+1)=val2
 1000 continue
        end
c
c
c
        subroutine insort3(k,a,b,c)
        implicit double precision (a-h,o-z)
        dimension a(1),b(1),c(1)
c
        do 1000 i=2,k
        val  = a(i)
        val2 = b(i)
        val3 = c(i)
        j    = i-1
        do 1100 while (j .ge. 1 .AND. a(j) .gt. val) 
        a(j+1)=a(j)
        b(j+1)=b(j)
        c(j+1)=c(j)
        j=j-1
 1100 continue
        a(j+1)=val
        b(j+1)=val2
        c(j+1)=val3
 1000 continue
c
        end
c
c
c
        subroutine insort4(k,a,b,c,d)
        implicit double precision (a-h,o-z)
        dimension a(1),b(1),c(1),d(1)
c
        do 1000 i=2,k
        val=a(i)
        val2=b(i)
        val3=c(i)
        val4=d(i)
        j=i-1
        do 1100 while (j .ge. 1 .AND. a(j) .gt. val) 
        a(j+1)=a(j)
        b(j+1)=b(j)
        c(j+1)=c(j)
        d(j+1)=d(j)
        j=j-1
 1100 continue
        a(j+1)=val
        b(j+1)=val2
        c(j+1)=val3
        d(j+1)=val4
 1000 continue
        end
c
c
c
        subroutine gauss_apply(n,m,a,x,y)
        implicit double precision (a-h,o-z)
        dimension a(n,m),x(m),y(n)
c
        do 1000 i=1,n
        sum=0
        do 1100 j=1,m
        sum=sum+a(i,j)*x(j)
 1100 continue
        y(i)=sum
 1000 continue
        end
c
c
c
        subroutine gauss_applyt(n,m,u,x,y)
        implicit double precision (a-h,o-z)
        dimension u(n,m),x(n),y(m)
c
        do 1000 i=1,m
        sum=0
        do 1100 j=1,n
        sum=sum+u(j,i)*x(j)
 1100 continue
        y(i)=sum
 1000 continue
        end
c
c
c
        subroutine gauss_matmul2(n,m,k,a,b,c)
        implicit double precision (a-h,o-z)
        dimension c(n,m),a(k,n),b(k,m)
c
c       c = a^*b
c
        do 1000 i=1,n
        do 1100 j=1,m
        sum=0
        do 1200 l=1,k
        sum=sum+a(l,i)*b(l,j)
 1200 continue
        c(i,j)=sum
 1100 continue
 1000 continue
        end
c
c
c
        subroutine gauss_matmul3(n,m,k,a,b,c)
        implicit double precision (a-h,o-z)
        dimension c(n,m),a(n,k),b(m,k)
c
        do 1000 i=1,n
        do 1100 j=1,m
        sum=0
        do 1200 l=1,k
        sum=sum+a(i,l)*b(j,l)
 1200 continue
        c(i,j)=sum
 1100 continue
 1000 continue
        end
c
c
c
        subroutine gaussmove(k,a,b)
        implicit double precision (a-h,o-z)
        dimension a(1),b(1)
        do 1000 j=1,k
        b(j)=a(j)
 1000 continue
        end
